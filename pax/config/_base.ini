##
# Base, TPC-independent configuration for pax
# Does NOT contain a complete working set of settings - you must load a TPC settings file!
##

# All values are run with eval()
#
# Unit convention: all values carrying physical units must be specified carrying units.
#   GOOD: resistor = 50 * Ohm
#   BAD:  resistor = 50         This is not just bad style, but will actually fail to do what you want,
#                               as the number representing 1 Ohm resistance internally is not 1.
# If you specify a count of something (number of samples, digitizer counts...),
# please indicate what is being counted using a comment, unless it is really obvious.
# GOOD: min_s2_width = 50 #Samples
#  BAD: min_s2_width = 50
#   OK: num_pmts = 242


[pax]
# Settings for pax core go here

# Plugin groups: plugins from these groups will be loaded (in order)
plugin_group_names = ['input', 'pre_dsp', 'dsp', 'compute_properties', 'pre_analysis', 'output']

# Plugins group lists
pre_dsp = []
dsp = []
compute_properties = []
pre_analysis = []
output = 'Table.TableWriter'

# Logging control
logging_level = 'INFO'

# Alternate search paths for plugins (none by default, see core for where it searches for plugins):
plugin_paths = []

# Prints a report on the time taken by each plugin at end of processing
print_timing_report = True


# Global settings, passed to every plugin
[DEFAULT]
tpc_name = "some random TPC which didn't specify its name in the config file"
run_number = 0   # TODO: get from run database
overwrite_output = 'confirm'

# PMT ranges - to be filled by TPC config
channels_top = []
channels_bottom = []

# CAEN V1724 used by XENON100 and XENON1T
sample_duration = int(10 * ns)      # int is necessary for data structure
digitizer_voltage_range = 2.25 * V
nominal_gain = 2.0* 10**6 #e-/pe    # Will not be used unless build_nominally_gain_corrected_waveforms=True below
digitizer_bits = 14
pmt_circuit_load_resistor = 50 * Ohm
external_amplification = 10

# Each channel's baseline will be determined dynamically
# This is merely the reference point
digitizer_reference_baseline = 16000

[SumWaveform.SumWaveform]
# If true, the 'tpc_raw', 'veto_raw' sum waveforms will be constructed WITHOUT subtracting the baseline correction
# Useful to see effect of baseline correction
# Note the raw sum waveform is for cosmetic (plotting) purposes only,
# it isn't (and shouldn't) be used for anything else
subtract_reference_baseline_only_for_raw_waveform = False



##
# Plotting settings
##
[Plotting]
waveforms_to_plot = (
        {'internal_name': 'tpc',      'plot_label': 'TPC (hits only)',
                    'drawstyle': 'steps', 'color':'black'},
        {'internal_name': 'tpc_raw',  'plot_label': 'TPC (raw)',
                    'drawstyle': 'steps', 'color':'black', 'alpha': 0.3},
        {'internal_name': 'veto',     'plot_label': 'Veto (hits only)',
                    'drawstyle': 'steps', 'color':'red'},
        {'internal_name': 'veto_raw', 'plot_label': 'Veto (raw)',
                    'drawstyle': 'steps', 'color':'red', 'alpha': 0.2},
    )
output_dir = None      # Output plots here. If option is None, will show interactive display.
plot_format = 'png'    # Can be pdf or png. No effect if output_dir is set.
plot_every = 1         # Skip plot_every-1 waveforms after plotting one
size_multiplier = 4    # Increase/decrease to get bigger/smaller plots

log_scale_entire_event = False
log_scale_s2 = False
log_scale_s1 = False

[Plotting.PlotEventSummary]
plot_largest_peaks = True      # On the top row, show zoom-ins of the largest S1, S2, and their hitpatterns

[Plotting.PlotChannelWaveforms3D]
log_scale = False



[MongoDB]
runs_database_location = {'address' : '127.0.0.1',
                         'database' : 'online',
                         'collection' : 'runs',
                         'port' : 27017}
start_key = 'time'
stop_key = 'endtime'

[XED.ReadXED]
input_name = "xe100_120402_2000_000000.xed"



[OnlineMonitor.OnlineMonitor]
address = "xedaq00"
database = "online"
collection = "monitor"
waveformcollection = "waveforms"


[Table.TableWriter]
output_format = 'hdf5'      # hdf5, csv, numpy, html, json, root

append_data = False
overwrite_data = True
string_data_length = 32

# Convert data to numpy records every n events
# These take less memory, but conversion takes some time
buffer_size = 50

# Write to file every time a chunk is converted to records
# If false, or output format does not support it, will write all at end
write_in_chunks = True

# Fields to leave out of the output.
# If you dump to e.g. json, you may want to ignore area_per_channel and does_channel_contribute
# You must ignore one of 'all_hits' (event field) or 'hits' (peak field)
# 'sum waveforms' must always be ignored
fields_to_ignore = ['sum_waveforms',
                    'channel_waveforms',
                    'all_hits',
                    'raw_data',
                    #'hits',
                    #'pulses',
                   ]



[Pickle.DirWithPickleFiles]
input_name = './pickled'


[RawWaveformDump]
extension  = 'dat'                                       # File extension used

[RawWaveformDump.DumpSumWaveformToBinary]
waveform_to_dump   = 'tpc'                               # SumWaveform which is dumped
dump_in_units = 'pe/bin'                                 # 'voltage' units: convert waveform back to raw voltage (using gain=2e6) before dumping
                                                         # 'pe/bin': leave as is (in pe/bin)

[Avro]
compresslevel = 4

events_per_file = 250

event_schema =  """
                { "namespace":"XENON",
                  "type":"record",
                   "name":"event",
                   "fields":[ {"name":"number", "type":"int"},
                              {"name":"start_time","type":"long"},
                              {"name":"stop_time","type":"long"},
                              {"name":"pulses",
                               "type":[ "null",
                                       {"type": "array",
                                       "items":{  "name":"pulse",
                                                  "type":"record",
                                                  "fields":[ {"name":"channel",  "type":"int"},
                                                             {"name":"left",  "type":"int"},
                                                               {"name":"payload",  "type":"bytes"}]}}],
                               "default":"null"},
                              {"name":"meta",
                               "type":[ "null",
                                        {"name":"metadata",
                                        "type":"record",
                                        "fields": [{"name":"run_number","type":"int"},
                                                   {"name":"tpc","type":"string"},
                                                   {"name":"file_builder_name","type":"string"},
                                                   {"name":"file_builder_version","type":"string"}]}],
                                        "default":"null"}]}
                """

[Pickle.WriteToStackedPickleFolder]
events_per_file = 250


[BSON]
events_per_file = 250
# By default, BSON-type formats are used for raw data
fields_to_ignore = ['all_hits',
                    'sum_waveforms',
                    'channel_waveforms',]

[BSON.WriteZippedBSON]
compresslevel = 4

[XED.WriteXED]
compresslevel = 4

# At the moment our hacked Xerawdp XML only supports one file...
events_per_file = float('inf')

# If the following is enabled, we'll write only 'skip2' control words rather than proper skip control words
# this appears to be the case in the XENON100 root files (at least 120402_2000_0000)
skip2_bug = False


##
# Simulator default settings
##

[WaveformSimulator]
truth_file_name =                     'fax_truth.csv'
event_repetitions =                   1                  # Simulate each event in the instruction file this many times (1 means: simulate just once, no repetitions)
magically_avoid_dead_pmts =           True
magically_avoid_s1_excluded_pmts =    False              # Photons magically avoid PMTs excluded in S1 peakfinding in the Xerawdp Imitation
                                                         # Regular pax peakfinding doesn't exclude any pmts

# Simulator performance settings
use_simplified_simulator_from =       5000 #photons      # Use faster, though slightly less accurate method for peaks with more than this number of photons
                                                         # Only works if you activate cheap_zle, otherwise photons aren't clustered into bunches first
pulse_width_cutoff =                  5                  # Assume PMT pulse is 0 after this many rise/fall times. Does not impact performance greatly.
pmt_pulse_time_rounding =             1 * ns             # Round PMT pulse start time to this resolution, so we can exploit caching.


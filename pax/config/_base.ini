##
# Base, TPC-independent configuration for pax
# Does NOT contain a complete working set of settings - you must load a TPC settings file!
##

# All values are run with eval()
#
# Unit convention: all values carrying physical units must be specified carrying units.
#   GOOD: resistor = 50 * Ohm
#   BAD:  resistor = 50         This is not just bad style, but will actually fail to do what you want,
#                               as the number representing 1 Ohm resistance internally is not 1.
# If you specify a count of something (number of samples, digitizer counts...),
# please indicate what is being counted using a comment, unless it is really obvious.
# GOOD: min_s2_width = 50 #Samples
#  BAD: min_s2_width = 50
#   OK: num_pmts = 242

# Settings for pax core
[pax]
# Plugin groups: plugins from these groups will be loaded (in order)
plugin_group_names = ['input', 'dsp', 'transform', 'my_postprocessing', 'output']

# Plugins group lists
input = 'WaveformSimulator.WaveformSimulatorFromCSV'
dsp = []                                               # TPC-specific file should define DSP to use
transform = ['PosSimple.PosRecWeightedSum']            # Default transforms, keep as-is
my_postprocessing = []                                 # More transforms, for user to override
output = 'Plotting.PlotEventSummary'

# Logging control
logging_level = 'INFO'

# Alternate search paths for plugins (none by default):
plugin_paths = []

# Prints a report on the time taken by each plugin at end of processing
print_timing_report = True


# Global settings, passed to every plugin
[DEFAULT]
tpc_name = "some random TPC which didn't specify its name in the config file"

# PMT ranges - to be filled by TPC config
channels_top = []
channels_bottom = []


# CAEN V1724 used by XENON100 and XENON1T
sample_duration = int(10 * ns)      # int is necessary for data structure
digitizer_voltage_range = 2.25 * V
nominal_gain = 2.0* 10**6 #e-/pe    # Will not be used unless build_nominally_gain_corrected_waveforms=True below
digitizer_bits = 14
pmt_circuit_load_resistor = 50 * Ohm
external_amplification = 10

# Each channel's baseline will be determined dynamically, except when that is truly impossible.
# In that case, pax will complain loudly, then use this value:
digitizer_baseline = 16000


[BuildWaveforms.BuildWaveforms]

# If True, allow occurrences partially outside event window
# They will be truncated to fit the event window
# If False, such occurrences cause an error
truncate_occurrences_partially_outside = False

baseline_sample_length = 46
build_nominally_gain_corrected_waveforms = False
reuse_baseline_for_adjacent_occurrences = False
rear_baselining_for_short_occurrences = False
# Median is probably better (more robust), though it  increases runtime of BuildWaveforms by 50%
find_baselines_using = 'mean'
zombie_paranoia=False


[Filtering]
simulate_Xerawdp_convolution_bug = False


[PosSimple.PosRecWeightedSum]
channels_to_use_for_reconstruction = 'top'



##
# I/O Plugin default settings
##
[Plotting]
waveforms_to_plot = (
        {'internal_name': 'tpc',  'plot_label': 'TPC (raw)', 'drawstyle': 'steps'},
        {'internal_name': 'tpc_s2',  'plot_label': 'TPC (filtered for s2)'},
        {'internal_name': 'veto', 'plot_label': 'Veto (raw)', 'drawstyle': 'steps'},
    )
output_dir = None      # Output plots here. If option is None, will show plots.
plot_every = 1         # Skip plot_every-1 waveforms after plotting one
size_multiplier = 4    # Increase/decrease to get bigger/smaller plots


log_scale_entire_event = True
log_scale_s2 = True
log_scale_s1 = False

[Plotting.PlotEventSummary]
plot_largest_peaks = True      # On the top row, show zoom-ins of the largest S1, S2, and their hitpatterns
#horizontal_size_multiplier = 1.5

[Plotting.PlotChannelWaveforms3D]
log_scale = False



[Mongo]
name = "dataset"
address = "localhost:27017"

[MongoDB.MongoDBInputTriggered]
database = "input"
collection = "dataset000002"
address = ${Mongo:address}

[MongoDB.MongoDBInput]
database = "output"
collection = ${Mongo:name}
address = ${Mongo:address}

[MongoDB.MongoDBFakeDAQOutput]
repeater = 0  # Hz, 0 means off
run_time = 300 # seconds

name = ${Mongo:name}
collect_then_dump = False

address = 'localhost:27017'
raw_address = ${address}
raw_database = "input"
raw_collection = ${name}

run_address = ${address}
run_database = "online"
run_collection = "runs"



[XED.XedInput]
input_name = "xe100_120402_2000_000000.xed"



[OnlineMonitor.OnlineMonitor]
address = "xedaq00"
database = "online"
collection = "monitor"
waveformcollection = "waveforms"



[Pandas.WritePandas]
# DEPRECATED -- use BulkOutput instead
# Pandas.WritePandas runs slower and produces larger files

# See plugin docstring for option descriptions
output_name = 'output'
output_format = 'hdf'   # Tested: hdf, csv, json, html (slow!), pickle
append_data = False
write_every = 50
# Fields to leave out of the output.
# If you dump to e.g. json, you may want to ignore area_per_channel and does_channel_contribute
fields_to_ignore = ['occurrences',
                    'sum_waveforms',
                    'channel_waveforms',
                    'all_channel_peaks',
                    'raw_data',
                   ]


[BulkOutput.BulkOutput]
output_format = 'HDF5Dump'
output_name = 'output'

append_data = False
overwrite_data = True
string_data_length = 32

# Convert data to numpy records every n events
# These take less memory, but conversion takes some time
convert_every = 50

# Write to file every time a chunk is converted to records
# If false, or output format does not support it, will write all at end
write_in_chunks = True

# Fields to leave out of the output.
# If you dump to e.g. json, you may want to ignore area_per_channel and does_channel_contribute
fields_to_ignore = ['occurrences',
                    'sum_waveforms',
                    'channel_waveforms',
                    'all_channel_peaks',
                    'raw_data',
                   ]


[Pickle.WriteToPickleFile]
output_name = './pickled'  # Directory to store pickle files in

[Pickle.DirWithPickleFiles]
input_name = './pickled'



[CSV.WritePeaksCSV]
output_name = 'output.csv'



[RawWaveformDump]
output_name = './waveforms'                               # Output waveforms here
extension  = 'dat'                                       # File extension used

[RawWaveformDump.DumpSumWaveformToBinary]
waveform_to_dump   = 'tpc'                               # SumWaveform which is dumped
dump_in_units = 'pe/bin'                                 # 'voltage' units: convert waveform back to raw voltage (using gain=2e6) before dumping
                                                         # 'pe/bin': leave as is (in pe/bin)


[Music.WavOutput]
output_name = 'sound.wav'


##
# Simulator default settings
##

[WaveformSimulator.WaveformSimulatorFromCSV]
input_name =                          'dummy_waveforms.csv'

[WaveformSimulator.WaveformSimulatorFromNEST]
input_name =                          'Neutron-4FaX-10k.root'

[WaveformSimulator]
truth_file_name =                     'fax_truth.csv'
event_repetitions =                   1                  # Simulate each event in the instruction file this many times (1 means: simulate just once, no repetitions)
magically_avoid_dead_pmts =           True
magically_avoid_s1_excluded_pmts =    True

# Simulator performance settings
use_simplified_simulator_from =       5000 #photons      # Use faster, though slightly less accurate method for peaks with more than this number of photons
pulse_width_cutoff =                  5                  # Assume PMT pulse is 0 after this many rise/fall times. Does not impact performance greatly.
pmt_pulse_time_rounding =             1 * ns             # Round PMT pulse start time to this resolution, so we can exploit caching.

# PMT characteristics
pmt_transit_time_mean     =           50  * ns           # PLACEHOLDER - PMT handbook upper limit for linear focussed pmt type
                                                         # Not a big issue I think, this merely shifts the entire waveform. Could even put it 0.
pmt_transit_time_spread   =           0.8 * ns           # xenon:xenon100:pmtdatasheets, Room temperature
pmt_rise_time             =           1.8 * ns           # xenon:xenon100:pmtdatasheets, Room temperature
pmt_fall_time             =           6.7 * ns           # PLACEHOLDER - Can't find this! Now chosen 3.7 * rise time, as for Lung et al. 2012 (X1T PMTs)
white_noise_sigma         =           0.05 #pe/bin       # Sigma of Gaussian noise applied separately to every PMT that has seen a photon

# Digitizer occurrence building simulation
zle_padding = 500 * ns      # Padding in an occurrence left of the first and right of the last photon
event_padding = 5 * us      # Padding in the event before the first and after the last photon
                            # if this is not larger than the zle padding, bad things happen

# Currently only used for s1 time structure calculations:
drift_field =                         530 * V /cm        # TODO add ref ('The xenon100 experiment'?)
liquid_density =                      3 * g / cm**3      # PLACEHOLDER

# S1
maximum_recombination_time =          50 * ns            # Prevents crazy recombination times from tail of hyperbolic distribution
s1_detection_efficiency   =           1 #0.08            # % photons detected, NSort
singlet_lifetime_liquid   =           3.1 * ns           # Nest 2014 p2
triplet_lifetime_liquid   =           24 * ns            # Nest 2014 p2
s1_ER_recombination_fraction =        0.9
#s1_ER_recombination_fraction =        0.6                # Only used for primary/secondary split, we don't do yield calculations here!
                                                         # Nest 2011 p4 for E = about 500 V/cm and LET 10 MeV cm^2 /g (which acc to Chepel&Araujo is for 30 keV ER (higher E, less rec.)
s1_ER_primary_singlet_fraction =      1/(1+1/0.17)       # Nest 2014 p2, converted from s/t ratio to s fraction. 0.17 +-0.05
s1_ER_secondary_singlet_fraction =    1/(1+1/0.8)        # Nest 2014 p2, assuming gamma-induced ER. 0.8 +- 0.2
s1_NR_singlet_fraction =              1/(1+1/7.8)        # Nest 2014 page 2. 7.8 +- 1.5

# S2 electron drift and extraction
electron_lifetime_liquid =            450 * us           # AmBe Run12 mean value, see e.g. xenon1t:sim:notes:morana:ambe:nest
drift_velocity_liquid     =           1.73*um/ns         # Andrea says 1.73 um/ns. Ethan's code has 1.8 mm/us.
drift_velocity_liquid_above_gate =    0.272*cm/us        # From the single electron paper
diffusion_constant_liquid =           12*cm**(2)/s       # Sorensen 2011, longitudinal diffusion. Ethan's code uses 70*cm**(2)/s! (0.007*mm**2/us)
electron_trapping_time    =           140*ns             # Nest 2014, but was obtained through fitting data
electron_extraction_yield =           1                  # "above 0.96" xenon:xenon100:analysis:maxime:s2afterpulses
gate_to_anode_distance =              5 * mm             # See e.g. single electron paper, several other places
elr_gas_gap_length =                  2.5*mm             # Xenon100 Analysis paper, page 4, "h_g ~ 2.5 mm"

# S2 electroluminescence
s2_secondary_sc_gain_density =        19.7/(2.5*mm)      # "secondary scintillation gain" per length unit. 19.7 from NSort. This automatically includes detection efficiencies.
drift_velocity_gas        =           3.6 * mm/us        # Jelle: Fit to Xenon100 single-e S2s [note tba]
anode_wire_radius         =           125/2*um           # GPlante p 98
anode_mesh_pitch          =           2.5*mm             # GPlante p 98
# field becomes wire-dominated (~1/r) at wire_field_parameter*anode_mesh_pitch
wire_field_parameter      =           0.19               # Jelle: Fit to Xenon100 single-e S2s [note tba]
singlet_lifetime_gas      =           5.88*ns            # Nest 2014. +- 5.5 (!!)
triplet_lifetime_gas      =           120*ns             # Jelle: Fit to Xenon100 single-e S2s [note tba]
                                                         # Nest 2014: 100.1*ns +- 7.9
singlet_fraction_gas      =           0                  # Jelle: Fit to Xenon100 single-e S2s [note tba]

[Avro]
# Run number
run_number = 0
input_name = 'data_input.avro'
output_name = 'data_output.avro'
raw_pulse_schema = """{"namespace":"XENON","type":"record","name":"event","fields":[{"name":"number","type":"int"},{"name":"start_time","type":"long"},{"name":"stop_time","type":"long"},{"name":"pulses","type":["null",{"type":"array","items":{"name":"pulse","type":"record","fields":[{"name":"channel","type":"int"},{"name":"left","type":"int"},{"name":"payload","type":"bytes"}]}}],"default":"null"},{"name":"meta","type":["null",{"name":"metadata","type":"record","fields":[{"name":"run_number","type":"int"},{"name":"tpc","type":"string"},{"name":"file_builder_version","type":"string"}]}],"default":"null"}]}"""


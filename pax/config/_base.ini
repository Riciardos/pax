##
# Base, TPC-independent configuration for pax
# Does NOT contain a compelte working set of settings - you must load a TPC settings file!
##

# All values are run with eval()
#
# Unit convention: all values carrying physical units must be specified carrying units.
#   GOOD: resistor = 50 * Ohm
#   BAD:  resistor = 50         This is not just bad style, but will actually fail to do what you want,
#                               as the number representing 1 Ohm resistance internally is not 1.
# If you specify a count of something (number of samples, digitizer counts...),
# please indicate what is being counted using a comment, unless it is really obvious.
# GOOD: min_s2_width = 50 #Samples
#  BAD: min_s2_width = 50
#   OK: num_pmts = 242

[pax]
# Plugin list (empty by default)
dsp = []                                               # TPC-specific file should define DSP to use
transform = ['PosSimple.PosRecWeightedSum']            # Default transforms, keep as-is
my_postprocessing = []  # More transforms, for user to override


# Alternate search paths for plugins (none by default):
plugin_paths = []

# Default choice of input and output
input = 'WaveformSimulator.WaveformSimulatorFromCSV'
output = 'Plotting.PlotWaveform'

# Global settings, passed to every plugin

[DEFAULT]
# None currently...
pmts_excluded_for_s1 = set([])

# V1724 used by XENON100 and XENON1T
digitizer_t_resolution = 10 * ns
digitizer_voltage_range = 2.25 * V
digitizer_bits = 14
pmt_circuit_load_resistor = 50 * Ohm
external_amplification = 10



##
# I/O Plugin default settings
##
[Plotting]
output_dir = None      # Output plots here. If option is None, will show plots.
plot_every = 1      # Skip plot_every-1 waveforms after plotting one

[Plotting.PlotWaveform]
waveforms_to_plot = (
        {'internal_name': 'uS2',  'plot_label': 'TPC (raw)'},
        {'internal_name': 'filtered_for_large_s2',  'plot_label': 'TPC (filtered for s2)'},
        {'internal_name': 'veto', 'plot_label': 'Veto (raw)'},
    )

[Mongo]
name = "dataset"
address = "localhost:27017"

[MongoDB.MongoDBInput]
database = "output"
collection = ${Mongo:name}
address = ${Mongo:address}

[MongoDB.MongoDBFakeDAQOutput]
repeater = 0  # Hz, 0 means off
run_time = 300 # seconds

name = ${Mongo:name}
collect_then_dump = False

address = 'localhost:27017'
raw_address = ${address}
raw_database = "input"
raw_collection = ${name}

run_address = ${address}
run_database = "online"
run_collection = "runs"


[XED.XedInput]
filename = "xe100_120402_2000_000000.xed"

[PeakFinding.ComputePeakProperties]
coincidence_threshold = 0.35  #pe

[OnlineMonitor.OnlineMonitor]
address = "xedaq00"
database = "online"
collection = "monitor"
waveformcollection = "waveforms"

[HDF5.HDF5Output]
hdf5file = 'output.h5'

[Pickle.WriteToPickleFile]
output_dir = './pickled'

[Pickle.DirWithPickleFiles]
input_dir = './pickled'

[CSV.WritePeaksCSV]
output_file = 'output.csv'


[RawWaveformDump]
output_dir = './waveforms'                               # Output waveforms here
extension  = 'dat'                                       # File extension used

[RawWaveformDump.DumpSumWaveformToBinary]
waveform_to_dump   = 'uS2'                               # Waveform which is dumped (recommended: uS2, this includes everything)
dump_in_units = 'voltage'                                # 'voltage' units: convert waveform back to raw voltage (using gain=2e6) before dumping
                                                         # 'pe/bin': leave as is (in pe/bin)


##
# Simulator default settings
##

[WaveformSimulator.WaveformSimulatorFromCSV]
instruction_filename =                'fax_instructions.csv'

[WaveformSimulator.WaveformSimulatorFromNEST]
input_file =                          'Neutron-4FaX-10k.root'

[WaveformSimulator]
truth_file_format =                   'csv_peaklist'     # Supported formats: stacked_pickles, csv_peaklist
truth_file_name =                     'fax_truth.csv'
event_repetitions =                   1                  # Simulate each event in the instruction file this many times (1 means: simulate just once, no repetitions)
magically_avoid_dead_pmts =           False
magically_avoid_s1_excluded_pmts =    False

# Simulator performance settings
use_simplified_simulator_from =       1000 #photons      # Use faster, slightly less accurate method for peaks with more than this number of photons
pulse_width_cutoff =                  5                  # Assume PMT pulse is 0 after this many rise/fall times

# Padding
pad_before =                          2*us               # Padding before a peak, with noise
pad_after =                           2*us               #         after
event_padding =                       0                  # Zero-padding at start and end of event, without noise

[PosSimple.PosRecWeightedSum]  
pmts_to_use_for_reconstruction = 'top'
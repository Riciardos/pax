##
# Base, TPC-independent configuration for pax
# Does NOT contain a compelte working set of settings - you must load a TPC settings file!
##

# All values are run with eval()
#
# Unit convention: all values carrying physical units must be specified carrying units.
#   GOOD: resistor = 50 * Ohm
#   BAD:  resistor = 50         This is not just bad style, but will actually fail to do what you want,
#                               as the number representing 1 Ohm resistance internally is not 1.
# If you specify a count of something (number of samples, digitizer counts...),
# please indicate what is being counted using a comment, unless it is really obvious.
# GOOD: min_s2_width = 50 #Samples
#  BAD: min_s2_width = 50
#   OK: num_pmts = 242

[pax]
# Plugin list (empty by default)
dsp = []                                               # TPC-specific file should define DSP to use
transform = ['PosSimple.PosRecWeightedSum']            # Default transforms, keep as-is
my_postprocessing = []  # More transforms, for user to override

# Logging control
logging_level = 'INFO'

# Alternate search paths for plugins (none by default):
plugin_paths = []

# Default choice of input and output
input = 'WaveformSimulator.WaveformSimulatorFromCSV'
output = 'Plotting.PlotEventSummary'

print_timing_report = True


# Global settings, passed to every plugin

[DEFAULT]
tpc_name = "some random TPC which didn't specify its name in the config file"

# PMT sets - to be filled by TPC config
pmts_top = set()
pmts_bottom = set()
pmts_veto = set()
pmts_excluded_for_s1 = set()

# CAEN V1724 used by XENON100 and XENON1T
digitizer_t_resolution = 10 * ns
digitizer_voltage_range = 2.25 * V
digitizer_bits = 14
pmt_circuit_load_resistor = 50 * Ohm
external_amplification = 10

# Each channel's baseline will be determined dynamically, except when that is truly impossible.
# In that case, pax will complain loudly, then use this value:
digitizer_baseline = 16000



[BuildWaveforms.BuildWaveforms]
build_nominally_gain_corrected_waveforms = True
nominal_pmt_gain = 2.0* 10**6 #pe / e
baseline_sample_length = 46
reuse_baseline_for_adjacent_occurrences = True
rear_baselining_for_short_occurrences = True
rear_baselining_threshold_occurrence_length = 92
zombie_paranoia = False  # If True, will warn you if a dead channel (gain=0) shows a signal


[newDSP.ComputePeakProperties]
# Waveforms to use for computing widths, index_of_filtered_maximum, ...
unfiltered_waveform_name = 'uS2'
filtered_waveform_name = 'filtered_for_large_s2'
minimum_pe_area = 0.35 #pe  # Minimum area seen in a PMT to count towards the coincidence level

[PeakFinding.FindPeaksXeRawDPStyle]
minimum_pe_area = 0.35 #pe  # Minimum area seen in a PMT to count towards the coincidence level


##
# I/O Plugin default settings
##
[Plotting]
output_dir = None      # Output plots here. If option is None, will show plots.
plot_every = 1         # Skip plot_every-1 waveforms after plotting one

# Interval names and labels of the waveforms to plot
waveforms_to_plot = (
        {'internal_name': 'uS2',  'plot_label': 'TPC (raw)'},
        {'internal_name': 'filtered_for_large_s2',  'plot_label': 'TPC (filtered for s2)'},
        {'internal_name': 'veto', 'plot_label': 'Veto (raw)'},
    )

log_scale_entire_event = True
log_scale_s2 = True
log_scale_s1 = False


[Mongo]
name = "dataset"
address = "localhost:27017"

[MongoDB.MongoDBInput]
database = "output"
collection = ${Mongo:name}
address = ${Mongo:address}

[MongoDB.MongoDBFakeDAQOutput]
repeater = 0  # Hz, 0 means off
run_time = 300 # seconds

name = ${Mongo:name}
collect_then_dump = False

address = 'localhost:27017'
raw_address = ${address}
raw_database = "input"
raw_collection = ${name}

run_address = ${address}
run_database = "online"
run_collection = "runs"


[XED.XedInput]
input_name = "xe100_120402_2000_000000.xed"

[PeakFinding.ComputePeakProperties]
coincidence_threshold = 0.35  #pe

[OnlineMonitor.OnlineMonitor]
address = "xedaq00"
database = "online"
collection = "monitor"
waveformcollection = "waveforms"

[HDF5.HDF5Output]
output_name = 'output.h5'

[Pickle.WriteToPickleFile]
output_name = './pickled'  # Directory to store pickle files in

[Pickle.DirWithPickleFiles]
input_name = './pickled'

[CSV.WritePeaksCSV]
output_name = 'output.csv'


[RawWaveformDump]
output_name = './waveforms'                               # Output waveforms here
extension  = 'dat'                                       # File extension used

[RawWaveformDump.DumpSumWaveformToBinary]
waveform_to_dump   = 'uS2'                               # Waveform which is dumped (recommended: uS2, this includes everything)
dump_in_units = 'voltage'                                # 'voltage' units: convert waveform back to raw voltage (using gain=2e6) before dumping
                                                         # 'pe/bin': leave as is (in pe/bin)


##
# Simulator default settings
##

[WaveformSimulator.WaveformSimulatorFromCSV]
input_name =                          'dummy_waveforms.csv'

[WaveformSimulator.WaveformSimulatorFromNEST]
input_name =                          'Neutron-4FaX-10k.root'

[WaveformSimulator]
truth_file_format =                   'csv_peaklist'     # Supported formats: stacked_pickles, csv_peaklist
truth_file_name =                     'fax_truth.csv'
event_repetitions =                   1                  # Simulate each event in the instruction file this many times (1 means: simulate just once, no repetitions)
magically_avoid_dead_pmts =           True
magically_avoid_s1_excluded_pmts =    True

# Simulator performance settings
use_simplified_simulator_from =       1000 #photons      # Use faster, slightly less accurate method for peaks with more than this number of photons
pulse_width_cutoff =                  5                  # Assume PMT pulse is 0 after this many rise/fall times

# Padding
pad_before =                          2*us               # Padding before a peak, with noise
pad_after =                           2*us               #         after
event_padding =                       10*us              # Zero-padding at start and end of event, without noise

# PMT characteristics
pmt_transit_time_mean     =           50  * ns           # PLACEHOLDER - PMT handbook upper limit for linear focussed pmt type
                                                         # Not a big issue I think, this merely shifts the entire waveform. Could even put it 0.
pmt_transit_time_spread   =           0.8 * ns           # xenon:xenon100:pmtdatasheets, Room temperature
pmt_rise_time             =           1.8 * ns           # xenon:xenon100:pmtdatasheets, Room temperature
pmt_fall_time             =           6.7 * ns           # PLACEHOLDER - Can't find this! Now chosen 3.7 * rise time, as for Lung et al. 2012 (X1T PMTs)
white_noise_sigma         =           0.5 * uA           # PLACEHOLDER - Sigma of Gaussian noise applied separately to every PMT that has seen a photon

# Currently only used for s1 time structure calculations:
drift_field =                         530 * V /cm        # TODO add ref ('The xenon100 experiment'?)
liquid_density =                      3 * g / cm**3      # PLACEHOLDER

# S1
maximum_recombination_time =          50 * ns            # Prevents crazy recombination times from tail of hyperbolic distribution
s1_detection_efficiency   =           1 #0.08            # % photons detected, NSort
singlet_lifetime_liquid   =           3.1 * ns           # Nest 2014 p2
triplet_lifetime_liquid   =           24 * ns            # Nest 2014 p2
s1_ER_recombination_fraction =        0.9
#s1_ER_recombination_fraction =        0.6                # Only used for primary/secondary split, we don't do yield calculations here!
                                                         # Nest 2011 p4 for E = about 500 V/cm and LET 10 MeV cm^2 /g (which acc to Chepel&Araujo is for 30 keV ER (higher E, less rec.)
s1_ER_primary_singlet_fraction =      1/(1+1/0.17)       # Nest 2014 p2, converted from s/t ratio to s fraction. 0.17 +-0.05
s1_ER_secondary_singlet_fraction =    1/(1+1/0.8)        # Nest 2014 p2, assuming gamma-induced ER. 0.8 +- 0.2
s1_NR_singlet_fraction =              1/(1+1/7.8)        # Nest 2014 page 2. 7.8 +- 1.5

# S2 electron drift and extraction
electron_lifetime_liquid =            450 * us           # AmBe Run12 mean value, see e.g. xenon1t:sim:notes:morana:ambe:nest
drift_velocity_liquid     =           1.73*um/ns         # Andrea says 1.73 um/ns. Ethan's code has 1.8 mm/us.
drift_velocity_liquid_above_gate =    0.272*cm/us        # From the single electron paper
diffusion_constant_liquid =           12*cm**(2)/s       # Sorensen 2011, longitudinal diffusion. Ethan's code uses 70*cm**(2)/s! (0.007*mm**2/us)
electron_trapping_time    =           140*ns             # Nest 2014, but was obtained through fitting data
electron_extraction_yield =           1                  # "above 0.96" xenon:xenon100:analysis:maxime:s2afterpulses
gate_to_anode_distance =              5 * mm             # See e.g. single electron paper, several other places
elr_gas_gap_length =                  2.5*mm             # Xenon100 Analysis paper, page 4, "h_g ~ 2.5 mm"

# S2 electroluminescence
s2_secondary_sc_gain_density =        19.7/(2.5*mm)      # "secondary scintillation gain" per length unit. 19.7 from NSort. This automatically includes detection efficiencies.
drift_velocity_gas        =           5.7*mm/us          # From http://xenon.physics.rice.edu/xe100/restricted/ymei/S2WaveformSim201001/, using E=12 kV/cm
                                                         # Nest S2widthposter.pdf: 5 mm/us produced best fit to Xenon10
anode_wire_radius         =           125/2*um           # GPlante p 98
anode_mesh_pitch          =           2.5*mm             # GPlante p 98
wire_field_parameter      =           0.5                # field becomes wire-dominated (~1/r) at wire_field_parameter*anode_mesh_pitch
singlet_lifetime_gas      =           5.88*ns            # Nest 2014. +- 5.5 (!!)
triplet_lifetime_gas      =           100.1*ns           # Nest 2014. +- 7.9
singlet_fraction_gas      =           1/(1 + 1/0.1)      # Nest source code G4S2light.cc line 232, graced with comment: "guess: revisit"

[PosSimple.PosRecWeightedSum]  
pmts_to_use_for_reconstruction = 'top'

[Music.WavOutput]
output_name = 'sound.wav'


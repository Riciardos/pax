# This config file is not functional by itself, you also need to load e.g. Xenon100 or XED

[pax]
dsp = [
       'BuildWaveforms.BuildWaveforms',
       'Filtering.Filtering',
       'PeakFinding.FindBigPeaks',
       'PeakProcessing.ComputePeakAreasAndCoincidence',
       'PeakProcessing.DeleteSmallPeaks',
       'PeakFinding.FindSmallPeaks',
       #'SplitPeaks.SplitPeaks',
       #'newDSP.PruneSmallPeaksNearLargePeaks',
       'PeakProcessing.ComputePeakWidths',
       #'PeakProcessing.ComputePeakEntropies',
       'PeakProcessing.IdentifyPeaks',
       ]

[Plotting]
waveforms_to_plot = (
        {'internal_name': 'tpc',  'plot_label': 'TPC (raw)', 'drawstyle': 'steps'},
        {'internal_name': 'tpc_s2',  'plot_label': 'TPC (filtered for s2)'},
        {'internal_name': 'veto', 'plot_label': 'Veto (raw)', 'drawstyle': 'steps'},
        #{'internal_name': 'tpc_s1',  'plot_label': 'TPC (filtered for s1)'},
        #{'internal_name': 'bandpass_attempt',  'plot_label': 'Attempt at bandpass filtering'},
    )

[BuildWaveforms.BuildWaveforms]
build_nominally_gain_corrected_waveforms = False

[Filtering.Filtering]
simulate_Xerawdp_convolution_bug = False
filters = (
        {'name' : 'bandpass_attempt',  'source' : 'tpc',
         'low_freq_bound': 1/(5*us),
         'high_freq_bound': 1/(0.5*us),
         'filter_order': 1, # Higher means: sharper drop-off in frequency response
        },
        {'name' : 'tpc_s2',  'source' : 'tpc',  'impulse_response' : (
            0.005452,  0.009142,  0.013074,  0.017179,  0.021381,  0.025597,  0.029746,  0.033740,  0.037499,
            0.040941,  0.043992,  0.046586,  0.048666,  0.050185,  0.051111,  0.051422,  0.051111,  0.050185,
            0.048666,  0.046586,  0.043992,  0.040941,  0.037499,  0.033740,  0.029746,  0.025597,  0.021381,
            0.017179,  0.013074,  0.009142,  0.005452
        )},
        {'name' : 'tpc_s1',  'source' : 'tpc',  'impulse_response' : (
            0.05, 0.1, 0.2, 0.3, 0.2, 0.1, 0.05
        )},
        {'name' : 'veto_s1', 'source' : 'veto', 'impulse_response' : (
            0.05, 0.1, 0.2, 0.3, 0.2, 0.1, 0.05
        )},
    )
    

[PeakFinding.FindBigPeaks]
# High-statistics peakfinding
peakfinders = [
        {
            'peakfinding_wave'          : 'tpc_s2',
            'unfiltered_wave'           : 'tpc',
            # Find peaks only if peakfinding_wave exceeds the following threshold:
            'threshold'                 : 0.15, # pe/bin
            # For at least this many samples:
            'min_interval_width'        : 30, #samples
            # Try to split the peak into subpeaks if the interval is wider than this many samples:
            'min_split_attempt_width'   : 120, #samples
            # Splitting is done by looking for local maxima ('peaks') and minima ('valleys')
            # If one or no peaks/valley pairs are found, the peak is not split.
            # To eliminate wiggle, cut peaks and valleys intelligently (keep ones with high p/v ratio)
            # until remainin peak/valley pairs satisfy the criteria below:
            'min_p_v_ratio'             : 2,
            'min_p_v_distance'          : 30, #samples
            'min_p_v_difference'        : 0.5, #pe/bin
        },
        {
            'peakfinding_wave'          : 'tpc_s1',
            'unfiltered_wave'           : 'tpc',
            'threshold'                 : 0.15, # pe/bin
            'peak_integration_bound'    : 0.01, # of maximum,
        },
        {
            'peakfinding_wave'          : 'veto_s1',
            'area_threshold'            : 20, # pe/bin
            'unfiltered_wave'           : 'veto',
            'threshold'                 : 0.15,  # pe/bin
            'peak_integration_bound'    : 0.01, # of maximum
            'ignore_previous_peaks'     : True,
            'force_peak_label'          : 'veto'
        },
    ]


[PeakProcessing.ComputePeakAreasAndCoincidence]
# A channel counts as 'contributing' if its area within the peak bounds is >= than:
minimum_area = 0.35 #pe
# Note the area is higher than usual (0.35pe), this is for high-energy peaks only
exclude_non_contributing_channels_from_area = True  # This is not done for the veto even if set to True

[PeakProcessing.DeleteSmallPeaks]
# Deletes low coincidence peaks, so the low-energy peakfinder can have a crack at them
prune_if_coincidence_lower_than = 7 #contributing PMTs
# Also delete low-area peaks
prune_if_area_lower_than = 50 #pe


[PeakFinding.FindSmallPeaks]
# Minimum sigma's above noise level for an excess in a channel to be regarded as a peak:
peak_minimum_sigma = 5

# Initial guess for the noise_sigma; will be refined during peakfinding.
# If set too high, peaks may not get found; if set too low, spurious peaks may be found in noise.
noise_sigma_guess = 0.05

# Stop small peakfinding after a large peak.
# This will increase performance, but you'll lose small S2s in the photo-ionization tail of large events.
# Setting this to 10000 on Ambe 120402's first 100 events shaves 1/3 off FindSmallPeaks runtime
# give_up_after_peak_of_size = 10000

# Filter each occurrence waveform with a simple impulse response filter
# It's your job to check this is normalized.
# Based on looking at a few 100 occurences, it looks like a simple sliding window [0.5, 0.5]
# may be slightly better than  [0.8, 0.2]. While [0.8, 0.2] looks more like our peaks, it
# doesn't suppress fluctuating noise as well.
# TODO: This could be studied with the waveform simulator.
filter_to_use = [0.5, 0.5]

# Output peakfinder diagnostic plots to directory
# Warning: this will produce LOTS of plots, processing will be EXTREMELY SLOW
# That's why they're called diagnostic plots...
# make_diagnostic_plots_in = 'diagnostic_plots'


[PeakProcessing.PruneSmallPeaksNearLargePeaks]
min_distance_to_large_peak = 40 #samples
large_peaks_start_from = 50 #pe
#S1s with area larger than the following are always preserved, no matter where they are:
always_keep_peaks_larger_than = 5 #pe
never_prune_peak_types = ['veto']

[PeakProcessing.ComputePeakEntropies]
normalization_mode = 'square'       # How to convert the signal to positive values: square or abs
# If the option below is set, we don't do entropy computation for pmts which don't contribute to signal
# This saves about 1/3 of the computation time in this plugin
only_for_contributing_pmts = False


[PeakProcessing.ComputePeakWidths]
width_computations = {
    'full_width_half_max' : {
        'waveform_to_use' : 'tpc',
        'fraction_of_max' : 0.5,
        'interpolate' :     True,
    },
    'full_width_tenth_max' : {
        'waveform_to_use' : 'tpc',
        'fraction_of_max' : 0.1,
        'interpolate' :     True,
    },
    'full_width_half_max_filtered' : {
        'waveform_to_use' : 'tpc_s2',
        'fraction_of_max' : 0.5,
        'interpolate' :     True,
    },
    'full_width_tenth_max_filtered' : {
        'waveform_to_use' : 'tpc_s2',
        'fraction_of_max' : 0.1,
        'interpolate' :     True,
    }
  }


[PeakProcessing.IdentifyPeaks]
s1_half_area_in = 10 #samples   #Number of samples which must contain >50% of area for a peak to count as S1

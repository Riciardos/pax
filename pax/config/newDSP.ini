# This config file is not functional by itself, you also need to load e.g. Xenon100 or XED

[pax]
dsp = [
       'BuildWaveforms.BuildWaveforms',

       'Filtering.Filtering',

       'BigPeakfinder.FindBigPeaks',

       'BigPeakProcessing.ComputePeakAreasAndCoincidence',
       'BigPeakProcessing.ComputePeakWidths',
       #'BigPeakProcessing.ComputePeakEntropies',
       'BigPeakProcessing.ClassifyBigPeaks',
       'BigPeakProcessing.DeleteSmallPeaks',

       'SmallPeakfinder.FindSmallPeaks',

       'SmallPeakProcessing.ClusterSmallPeaks',
       'SmallPeakProcessing.AdHocClassification',

       ]

[Plotting]
waveforms_to_plot = (
        {'internal_name': 'tpc',  'plot_label': 'TPC (raw)', 'drawstyle': 'steps'},
        {'internal_name': 'tpc_s2',  'plot_label': 'TPC (filtered for s2)'},
        {'internal_name': 'veto', 'plot_label': 'Veto (raw)', 'drawstyle': 'steps'},
        #{'internal_name': 'tpc_s1',  'plot_label': 'TPC (filtered for s1)'},
        #{'internal_name': 'bandpass_attempt',  'plot_label': 'Attempt at bandpass filtering'},
    )

[BuildWaveforms.BuildWaveforms]
build_nominally_gain_corrected_waveforms = False
reuse_baseline_for_adjacent_occurrences = False
rear_baselining_for_short_occurrences = False
# Median is probably better (more robust), though it  increases runtime of BuildWaveforms by 50%
find_baselines_using = 'median'


[Filtering.Filtering]
simulate_Xerawdp_convolution_bug = False
filters = (
        {'name' : 'bandpass_attempt',  'source' : 'tpc',
         'low_freq_bound': 1/(5*us),
         'high_freq_bound': 1/(0.5*us),
         'filter_order': 1, # Higher means: sharper drop-off in frequency response
        },
        {'name' : 'tpc_s2',  'source' : 'tpc',  'impulse_response' : (
            0.005452,  0.009142,  0.013074,  0.017179,  0.021381,  0.025597,  0.029746,  0.033740,  0.037499,
            0.040941,  0.043992,  0.046586,  0.048666,  0.050185,  0.051111,  0.051422,  0.051111,  0.050185,
            0.048666,  0.046586,  0.043992,  0.040941,  0.037499,  0.033740,  0.029746,  0.025597,  0.021381,
            0.017179,  0.013074,  0.009142,  0.005452
        )},
        {'name' : 'tpc_s1',  'source' : 'tpc',  'impulse_response' : (
            0.05, 0.1, 0.2, 0.3, 0.2, 0.1, 0.05
        )},
        {'name' : 'veto_s1', 'source' : 'veto', 'impulse_response' : (
            0.05, 0.1, 0.2, 0.3, 0.2, 0.1, 0.05
        )},
    )
    

[BigPeakfinder.FindBigPeaks]
# High-statistics peakfinding
peakfinders = [
        {
            'peakfinding_wave'          : 'tpc_s2',
            'unfiltered_wave'           : 'tpc',
            # Find peaks only if peakfinding_wave exceeds the following threshold:
            'threshold'                 : 0.15, # pe/bin
            # For at least this many samples:
            'min_interval_width'        : 30, #samples
            # Try to split the peak into subpeaks if the interval is wider than this many samples:
            'min_split_attempt_width'   : 120, #samples
            # Splitting is done by looking for local maxima ('peaks') and minima ('valleys')
            # If one or no peaks/valley pairs are found, the peak is not split.
            # To eliminate wiggle, cut peaks and valleys intelligently (keep ones with high p/v ratio)
            # until remainin peak/valley pairs satisfy the criteria below:
            'min_p_v_ratio'             : 2,
            'min_p_v_distance'          : 30, #samples
            'min_p_v_difference'        : 0.5, #pe/bin
        },
        {
            'peakfinding_wave'          : 'tpc_s1',
            'unfiltered_wave'           : 'tpc',
            'threshold'                 : 0.15, # pe/bin
            'peak_integration_bound'    : 0.01, # of maximum,
        },
        {
            'peakfinding_wave'          : 'veto_s1',
            'area_threshold'            : 20, # pe/bin
            'unfiltered_wave'           : 'veto',
            'threshold'                 : 0.15,  # pe/bin
            'peak_integration_bound'    : 0.01, # of maximum
        },
    ]

[BigPeakProcessing.ClassifyBigPeaks]
central_area_ratio = 0.5  #If central_area >= this number * area, it is an S1


[BigPeakProcessing.ComputePeakAreasAndCoincidence]
# A channel counts as 'contributing' if its area within the peak bounds is >= than:
# Note the area is higher than usual (0.35pe), this is for high-energy peaks only
minimum_area = 0.35 #pe

# Width of the central region used in S1/S2 identification
central_area_region_width = 50 * ns


[BigPeakProcessing.ComputePeakEntropies]
normalization_mode = 'square'       # How to convert the signal to positive values: square or abs


[BigPeakProcessing.ComputePeakWidths]
width_computations = {
    'full_width_half_max' : {
        'waveform_to_use' : 'tpc',
        'fraction_of_max' : 0.5,
        'interpolate' :     True,
    },
    'full_width_tenth_max' : {
        'waveform_to_use' : 'tpc',
        'fraction_of_max' : 0.1,
        'interpolate' :     True,
    },
    'full_width_half_max_filtered' : {
        'waveform_to_use' : 'tpc_s2',
        'fraction_of_max' : 0.5,
        'interpolate' :     True,
    },
    'full_width_tenth_max_filtered' : {
        'waveform_to_use' : 'tpc_s2',
        'fraction_of_max' : 0.1,
        'interpolate' :     True,
    }
  }


[BigPeakProcessing.DeleteSmallPeaks]
# Deletes low coincidence peaks, so the low-energy peakfinder can have a crack at them
prune_if_coincidence_lower_than = 7 #contributing PMTs
# Also delete low-area peaks
# Setting this from 100->1000 increased runtime of this plugin by about 50%
# ... it also appears the ad-hoc MAD classification fails on higher peaks... so keep this low.
prune_if_area_lower_than = 100 #pe


[SmallPeakfinder.FindSmallPeaks]
# Minimum sigma's above noise level for an excess in a channel to be regarded as a peak:
peak_minimum_sigma = 5

# Initial guess for the noise_sigma; will be refined during peakfinding.
# If set too high, peaks may not get found; if set too low, spurious peaks may be found in noise.
noise_sigma_guess = 0.05 #pe/bin#

# Stop small peakfinding after a large peak.
# This will increase performance, but you'll lose small S2s in the photo-ionization tail of large events.
# Setting this to 10000 on Ambe 120402's first 100 events more than doubles FindSmallPeaks' speed
give_up_after_peak_of_size = 100000

# Filter each occurrence waveform with a simple impulse response convolution
# It's your job to check this is normalized!
# Based on looking at a few 100 occurences, it looks like a simple sliding window [0.5, 0.5]
# may be slightly better than e.g. [0.8, 0.2]. While [0.8, 0.2] looks more like our peaks, it
# doesn't suppress fluctuating noise as well.
# TODO: This could be studied with the waveform simulator, or looking at lots of diagnostic plots.
filter_to_use = [0.5, 0.5]

# FindSmallPeaks knows how many 'noise occurrences' (occurrences which contain no peaks) there are in each channel
# If a channel includes more than the below number of noise occurrences, it is marked as bad in this event
# This will lead IdentifySmallPeaks to not conside peaks from these channels,
# and cause them to appear grayed out in PlotChannelWaveforms2d)
maximum_noise_occurrences_per_channel = 2

# Output peakfinder diagnostic plots to directory
# Warning: this will produce LOTS of plots, processing will be EXTREMELY SLOW
# That's why they're called diagnostic plots...
# make_diagnostic_plots_in = 'diagnostic_plots'

# The algorithm refines its noise_sigma by excluding all samples part of a peak.
# Then peakfinding is repeated, then noise_sigma finding, etc.
# In principle this process is self-stabilizing, so it rarely takes more than 3 or 4 passes.
# In very rare occasions we never settle on peaks and the noise_sigma remains oscillatory.
# To protect against infinite loops, if more than the below number of passes have been done,
#  no new pass is started, and a loud warning ensues.
# Don't set this too low, or you'll be flooded with warnings.
max_noise_detection_passes = 20

# Method used to compute the noise level
# can be std (for standard deviation) or mad (for median absolute deviation)
# Looks like mad usually gives about 1/3 lower noise level
# Maybe mad is stabler though.. have to test this
noise_determination_method = 'std'


[SmallPeakProcessing.ClusterSmallPeaks]
# If spe peaks are separated by less than this, they will be clustered together
cluster_separation_time = 0.8 * us

# FindSmallPeaks knows how many 'lone pulses' there are in each channel
# If a channel includes more than the below number of lone pulses, it is marked as bad in this event
# This will lead IdentifySmallPeaks to not conside peaks from these channels,
# and cause them to appear grayed out in PlotChannelWaveforms2d)
maximum_lone_pulses_per_channel = 1

exclude_bad_channels = True

# This config file is not functional by itself, you also need to load e.g. Xenon100 or XED

[pax]
dsp = ['BuildWaveforms.BuildWaveforms',
       'Filtering.Filtering',
       'newDSP.FindBigPeaks',
       #'SplitPeaks.SplitPeaks',
       'newDSP.ComputePeakAreas',
       #'newDSP.PruneSmallPeaksNearLargePeaks',
       'newDSP.ComputePeakWidths',
       'newDSP.ComputePeakEntropies',
       'newDSP.IdentifyPeaks',
       ]

[Plotting]
waveforms_to_plot = (
        {'internal_name': 'veto', 'plot_label': 'Veto (raw)'},
        {'internal_name': 'tpc',  'plot_label': 'TPC (raw)'},
        {'internal_name': 'tpc_s2',  'plot_label': 'TPC (filtered for s2)'},
        {'internal_name': 'tpc_s1',  'plot_label': 'TPC (filtered for s1)'},
        {'internal_name': 'bandpass_attempt',  'plot_label': 'Attempt at bandpass filtering'},
    )

[BuildWaveforms.BuildWaveforms]
build_nominally_gain_corrected_waveforms = False

[Filtering.Filtering]
simulate_Xerawdp_convolution_bug = False
filters = (
        {'name' : 'bandpass_attempt',  'source' : 'tpc',
         'low_freq_bound': 1/(5*us),
         'high_freq_bound': 1/(0.5*us),
         'filter_order': 1, # Higher means: sharper drop-off in frequency response
        },
        {'name' : 'tpc_s2',  'source' : 'tpc',  'impulse_response' : (
            0.005452,  0.009142,  0.013074,  0.017179,  0.021381,  0.025597,  0.029746,  0.033740,  0.037499,
            0.040941,  0.043992,  0.046586,  0.048666,  0.050185,  0.051111,  0.051422,  0.051111,  0.050185,
            0.048666,  0.046586,  0.043992,  0.040941,  0.037499,  0.033740,  0.029746,  0.025597,  0.021381,
            0.017179,  0.013074,  0.009142,  0.005452
        )},
        {'name' : 'tpc_s1',  'source' : 'tpc',  'impulse_response' : (
            0.05, 0.1, 0.2, 0.3, 0.2, 0.1, 0.05
        )},
        {'name' : 'veto_s1', 'source' : 'veto', 'impulse_response' : (
            0.05, 0.1, 0.2, 0.3, 0.2, 0.1, 0.05
        )},
    )
    

[newDSP.FindBigPeaks]
# High-statistics peakfinding
peakfinders = [
        {
            'peakfinding_wave'          : 'tpc_s2',
            'unfiltered_wave'           : 'tpc',
            # Find peaks only if peakfinding_wave exceeds the following threshold:
            'threshold'                 : 0.15, # pe/bin
            # Ignore peaks whose area falls below the following threshold:
            # (so the low-energy peakfinder will look at them)
            'area_threshold'            : 50, # pe/bin
            # For at least this many samples:
            'min_interval_width'        : 30, #samples
            # Try to split the peak into subpeaks if the interval is wider than this many samples:
            'min_split_attempt_width'   : 120, #samples
            # Splitting is done by looking for local maxima ('peaks') and minima ('valleys')
            # If one or no peaks/valley pairs are found, the peak is not split.
            # To eliminate wiggle, cut peaks and valleys intelligently (keep ones with high p/v ratio)
            # until remainin peak/valley pairs satisfy the criteria below:
            'min_p_v_ratio'             : 2,
            'min_p_v_distance'          : 30, #samples
            'min_p_v_difference'        : 0.5, #pe/bin
        },
        {
            'peakfinding_wave'          : 'tpc_s1',
            'unfiltered_wave'           : 'tpc',
            'area_threshold'            : 50, # pe/bin
            'threshold'                 : 0.15, # pe/bin
            'peak_integration_bound'    : 0.01, # of maximum,
        },
        {
            'peakfinding_wave'          : 'veto_s1',
            'area_threshold'            : 50, # pe/bin
            'unfiltered_wave'           : 'veto',
            'threshold'                 : 0.15,  # pe/bin
            'peak_integration_bound'    : 0.01, # of maximum
            'ignore_previous_peaks'     : True,
            'force_peak_label'          : 'veto'
        },
    ]


[newDSP.ComputePeakAreas]
exclude_non_contributing_channels_from_area = True
minimum_area = 0.35 #pe


[newDSP.PruneSmallPeaksNearLargePeaks]
min_distance_to_large_peak = 40 #samples
large_peaks_start_from = 50 #pe
#S1s with area larger than the following are always preserved, no matter where they are:
always_keep_peaks_larger_than = 5 #pe
never_prune_peak_types = ['veto']

[newDSP.ComputePeakEntropies]
normalization_mode = 'square'       # How to convert the signal to positive values: square or abs
# If the option below is set, we don't do entropy computation for pmts which don't contribute to signal
# This saves about 1/3 of the computation time in this plugin
only_for_contributing_pmts = False


[newDSP.ComputePeakWidths]
width_computations = {
    'full_width_half_max' : {
        'waveform_to_use' : 'tpc',
        'fraction_of_max' : 0.5,
        'interpolate' :     True,
    },
    'full_width_tenth_max' : {
        'waveform_to_use' : 'tpc',
        'fraction_of_max' : 0.1,
        'interpolate' :     True,
    },
    'full_width_half_max_filtered' : {
        'waveform_to_use' : 'tpc_s2',
        'fraction_of_max' : 0.5,
        'interpolate' :     True,
    },
    'full_width_tenth_max_filtered' : {
        'waveform_to_use' : 'tpc_s2',
        'fraction_of_max' : 0.1,
        'interpolate' :     True,
    }
  }



[newDSP.IdentifyPeaks]
s1_half_area_in = 5 #samples   #Number of samples which must contain >50% of area for a peak to count as S1


[SplitPeaks.SplitPeaks]

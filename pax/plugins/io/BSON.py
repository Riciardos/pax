"""
JSON and BSON-based data output
"""
import json
import pickle
import zipfile
import gzip
import io

import bson
from rsa import bigfile as rsa_bigfile

from pax import datastructure, utils, exceptions
from pax.FolderIO import InputFromFolder, WriteToFolder


##
# JSON
##

class ReadJSON(InputFromFolder):

    """Read raw data from a folder of newline-separated-JSON files
    """
    file_extension = 'json'

    def open(self, filename):
        self.current_file = open(filename, mode='r')

    def get_all_events_in_current_file(self):
        for line in self.current_file:
            yield datastructure.Event(**json.loads(line))

    def close(self):
        self.current_file.close()


class WriteJSON(WriteToFolder):

    """Write raw data to a folder of newline-separated-JSON files
    """
    file_extension = 'json'

    def open(self, filename):
        self.current_file = open(filename, mode='w')

    def write_event_to_current_file(self, event):
        self.current_file.write(event.to_json(fields_to_ignore=self.config['fields_to_ignore']))
        self.current_file.write("\n")

    def close(self):
        self.current_file.close()


##
# BSON
##

class ReadBSON(InputFromFolder):

    """Read raw BSON data from a concatenated-BSON file or a folder of such files
    """
    file_extension = 'bson'

    def open(self, filename):
        self.current_file = open(filename, mode='rb')
        self.reader = bson.decode_file_iter(self.current_file)

    def close(self):
        self.current_file.close()

    def get_all_events_in_current_file(self):
        for doc in self.reader:
            yield datastructure.Event(**doc)


class WriteBSON(WriteToFolder):

    """Write raw data to a folder of concatenated-BSON files
    """
    file_extension = 'bson'

    def open(self, filename):
        self.current_file = open(filename, mode='wb')

    def write_event_to_current_file(self, event):
        self.current_file.write(event.to_bson(fields_to_ignore=self.config['fields_to_ignore']))

    def close(self):
        self.current_file.close()


##
# Zipped BSON
##

class ReadZippedBSON(InputFromFolder):

    """Read a folder of zipfiles containing gzipped BSON files
    If an encrypted event is encountered and decryption_key_file is specified, the event will be decrypted.
    If an encrypted event is encountered and decryption_key_file is NOT specified, a CantReadBlindedevent exception
    is raised. If pax is told to iterate over a whole file, this will merely cause the event to be skipped.
    If pax is asked for a specific event (e.g. with --event), it will halt pax.
    """
    file_extension = 'zip'

    def startup(self):
        super().startup()
        if 'decryption_key_file' in self.config:
            with open(utils.data_file_name(self.config['decryption_key_file']), 'rb') as f:
                self.decryption_key = pickle.load(f)

    def open(self, filename):
        self.current_file = zipfile.ZipFile(filename)
        self.event_numbers = sorted([int(x)
                                     for x in self.current_file.namelist()])

    def get_single_event_in_current_file(self, event_i):
        event_number = self.event_numbers[event_i]
        with self.current_file.open(str(event_number)) as event_file_in_zip:
            doc = event_file_in_zip.read()

            try:
                doc = gzip.decompress(doc)
            except OSError:
                # The event is encrypted
                if 'decryption_key_file' in self.config:
                    doc = decrypt_rsa(doc, self.decryption_key)
                    doc = gzip.decompress(doc)
                else:
                    raise exceptions.CantReadBlindedEvent("Event %d is blinded and hence cannot be read "
                                                          "without a decryption key" % event_number)

            return datastructure.Event.from_bson(doc)

    def close(self):
        """Close the currently open file"""
        self.current_file.close()


class WriteZippedBSON(WriteToFolder):

    """Write raw data to a folder of zipfiles containing gzipped BSONs
    If blinding_condition and encryption_key are specified, events for which blinding_condition is True
    will be encrypted by encryption_key.
      - blinding_condition should be a string containing a lambda function taking event and config
        (couldn't just put a lambda in, then configuration couldn't be JSONed anymore)
      - encryption_key should be a pickle file containing an rsa public key (generated by the python rsa module)
    """
    file_extension = 'zip'

    def startup(self):
        super().startup()
        if bool('encryption_key_file' in self.config) != bool('blinding_condition' in self.config):
            raise ValueError('encryption_key_file and blinding_condition should be both absent or both present')
        if 'encryption_key_file' in self.config:
            with open(utils.data_file_name(self.config['encryption_key_file']), 'rb') as f:
                self.encryption_key = pickle.load(f)
            # Get the lambda function out of the string
            self.blinding_condition = eval(self.config['blinding_condition'])

    def open(self, filename):
        self.current_file = zipfile.ZipFile(filename, mode='w')

    def write_event_to_current_file(self, event):
        event_data = gzip.compress(event.to_bson(fields_to_ignore=self.config['fields_to_ignore']),
                                   self.config['compresslevel'])

        if 'encryption_key_file' in self.config:
            should_be_blinded = self.blinding_condition(event=event, config=self.config)
            if should_be_blinded:
                event_data = encrypt_rsa(event_data, self.encryption_key)

        self.current_file.writestr(str(event.event_number), event_data)

    def close(self):
        self.current_file.close()


def encrypt_rsa(data, key):
    # Open fake binary files to interface with rsa module
    infile = io.BytesIO(data)
    outfile = io.BytesIO()
    rsa_bigfile.encrypt_bigfile(infile, outfile, key)
    return outfile.getvalue()


def decrypt_rsa(data, key):
    # Open fake binary files to interface with rsa module
    infile = io.BytesIO(data)
    outfile = io.BytesIO()
    rsa_bigfile.decrypt_bigfile(infile, outfile, key)
    return outfile.getvalue()

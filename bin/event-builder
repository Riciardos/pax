#!/usr/bin/env python
""" Processor for Analyzing XENON - command line interface """

import argparse
import logging
import pymongo
import sys
import multiprocessing
import time
from pax import core

class Consumer(multiprocessing.Process):

    def __init__(self, task_queue, result_queue,
                 config_names, config_dict):
        multiprocessing.Process.__init__(self)
        self.task_queue = task_queue
        self.result_queue = result_queue

        self.config_names = config_names
        self.config_dict = config_dict

    def run(self):
        proc_name = self.name

        p = core.Processor(config_names=self.config_names,
                           config_dict=self.config_dict)

        while True:
            next_event = self.task_queue.get()
            if next_event is None:
                # Poison pill means shutdown
                print(('%s: Exiting' % proc_name))
                self.task_queue.task_done()
                break

            answer = p.process_event(next_event)

            self.task_queue.task_done()
            self.result_queue.put(answer)
        return

##
# Parse command line arguments
##
def main():
    parser = argparse.ArgumentParser(description="Build XENON1T events from the"
                                                 " data aquisiton. This tools "
                                                 "starts the distributed "
                                                 "processing of events.")



    mode_group = parser.add_argument_group(title='Event builder modes',
                                           description='The event builder can '
                                                        'be started in various '
                                                        'different '
                                                        'configurations.')
    group = mode_group.add_mutually_exclusive_group(required=True)
    group.add_argument('--master',
                       action='store_true',
                       help='Start master that feeds the workers.')
    group.add_argument('--worker',
                       action='store_true',
                       help='Information on starting worker nodes')

    group.add_argument('--standalone',
                       action='store_true',
                       help='Run event builder in single threaded mode '
                            '(for testing)')



    run_db_str = 'The runs database stores all metadata about runs, including'\
                 ' which are waiting to be triggered. Communication is ' \
                 'required to find data.  More information on the MongoDB ' \
                 'jargon (e.g., "collection") can be found in their docs.'

    run_db_group = parser.add_argument_group(title='Runs database settings',
                                             description=run_db_str)
    run_db_group.add_argument('--address',
                              default='127.0.0.1',
                              help='Address or hostname of MongoDB instance.')
    run_db_group.add_argument('--database',
                              default='online',
                              help='')
    run_db_group.add_argument('--collection',
                              default='runs',
                              help='')
    run_db_group.add_argument('--port',
                              default=27017,
                              type=int,
                              help='Listening port of MongoDB.')


    parser.add_argument('--wait',
                        default=1,
                        type=int,
                        help="Wait time between searching if no data")
    # Log level control
    parser.add_argument('--log', default=None, help="Set log level, e.g. 'debug'")

    # set up logging to file - see previous section for more details
    logging.basicConfig(level=logging.DEBUG,
                        format='%(asctime)s %(name)s %(levelname)-8s %(message)s',
                        datefmt='%m-%d %H:%M',
                        filename='myapp.log',
                        filemode='w')
    # define a Handler which writes INFO messages or higher to the sys.stderr
    console = logging.StreamHandler()
    console.setLevel(logging.DEBUG)
    # set a format which is simpler for console use
    formatter = logging.Formatter('%(asctime)s %(name)-12s: %(levelname)-8s %(message)s')
    # tell the handler to use this format
    console.setFormatter(formatter)
    # add the handler to the root logger
    logging.getLogger('').addHandler(console)
    log = logging.getLogger('eb')

    args = parser.parse_args()

    if args.worker:
        log.info("To start a worker, you have to initialize pax via celery.")
        log.info("This can be done with the following command:")
        log.info("\tcelery -A pax.event_builder worker")
        return

    print(args)




    query = {"trigger.status" : "waiting_to_be_processed"}


    log.info("Searching for run")

    client = pymongo.MongoClient(args.address,
                                 args.port,
                                 serverSelectionTimeoutMS=500)
    try:
        client.admin.command('ping')
        log.debug("Connection successful to %s:%d",
                  args.address,
                  args.port)
    except pymongo.errors.ConnectionFailure:
        log.fatal("Cannot connect to MongoDB at %s:%d" % (args.address,
                                                          args.port))
        raise

    log.debug('Fetching databases: %s', args.database)
    db = client.get_database(args.database)

    log.debug('Getting collection: %s', args.collection)
    collection = db.get_collection(args.collection)

    while 1:
        run_doc = collection.find_one_and_update(query,
                                             {'$set': {'trigger.status' : 'staging'}})

        if run_doc is None:
            log.info("No data to process... waiting %d seconds",
                         args.wait)
            time.sleep(args.wait)
        else:
            log.info("Building events for %s",
                         run_doc['name'])

            filename = 'raw_%s.avro' % run_doc['name']

            config_names = 'eventbuilder'
            config_dict = {'DEFAULT' : {'run_doc' : run_doc['_id']},
                                        'output_name' : filename,
                                        'MongoDB' : {'runs_database_location' : {'address' : args.address,
                                                                                 'database' : args.database,
                                                                                 'port' : args.port,
                                                                                 'collection' : args.collection}}}
            try:
                p = core.Processor(config_names=config_names,
                                   config_dict=config_dict)

                p.run()

            except pymongo.errors.ServerSelectionTimeoutError as e:
                log.exception(e)
                collection.update(query,
                                  {'$set': {'trigger.status' : 'error'}})

if __name__ == "__main__":
    main()

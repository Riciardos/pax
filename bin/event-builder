#!/usr/bin/env python
"""Command line script for driving the XENON1T event builder

The event builder is responsible for turning the DAQ output (a stream of dititizer pulses)
into a zipped BSON with events ready for processing.

This code will need to make a connection to the XENON1T runs database, as the event builder
uses the runs database database to locate what data needs to be processed,
get appropriate settings for each run, and write status information when done with a run.

The data generated by the event builder will be placed in /data/xenon1t/run_name.
"""
import argparse
import logging
import os
import time
import socket
import shutil

import pymongo

from pax import core, units
from pax.MongoManager import MongoManager


def get_hostname():
    return socket.gethostname().split('.')[0]


def main():
    """Start running the event builder
    """
    args = get_command_line_arguments()
    log = setup_logging(loglevel=args.log)

    mongo_manager = MongoManager(config={k: eval('args.%s' % k, dict(args=args))
                                         for k in ('user', 'password', 'host', 'port')})
    runs = mongo_manager.get_database('run').get_collection('runs_new')

    # Build the query used to search for runs
    status_name = 'trigger.status'
    if args.run_name:
        run_query = {'name': args.run_name}
    elif args.run is not None:
        run_query = {'number': args.run}
    else:
        run_query = {status_name: 'waiting_to_be_processed'}
    run_query['detector'] = args.detector
    log.info("Starting run search with query %s" % run_query)

    while 1:
        if not args.secret_mode:
            run_doc = runs.find_one_and_update(run_query, {'$set': {status_name: 'staging'}})
            data_info_entry = {'type': 'raw',
                               'host': get_hostname(),
                               'status': 'transferring',
                               'location': os.path.join('/data/xenon1t_data', run_doc['name']),
                               'checksum': None}
            runs.update({'_id': run_doc['_id']},
                        {'$push': {'data': data_info_entry}})
        else:
            run_doc = runs.find_one(run_query)
            if run_doc is None:
                raise ValueError("Mongodb returned None instead of run document!")
            data_info_entry = dict(location=os.path.join('.', run_doc['name']))
            
        if run_doc is None:
            if args.impatient:
                log.info("Too impatient to wait for data, exiting...")
                break
            else:
                log.info("No runs to process yet... waiting %d seconds", args.wait)
                time.sleep(args.wait)
        else:
            # Override MongoDB settings
            mongo_settings_override = {}
            for argname in ('detector', 'user', 'password', 'host', 'port', 'secret_mode'):
                argval = getattr(args, argname)
                if argval is not None:
                    mongo_settings_override[argname] = argval
            if args.search_window is not None:
                mongo_settings_override['search_window'] = args.search_window * units.s

            # Override trigger settings
            #   First priority: command line args
            #   Second priority: rundb settings (from run_doc['trigger']['config'])
            #   Third priority: defaults from pax configuration (pax will take care of this)
            trigger_settings_override = {}
            if not args.ignore_rundb_trigger_settings:
                trigger_settings_override.update(run_doc['trigger'].get('config', {}))
            for argname, factor in (('left_extension', units.us),
                                    ('right_extension', units.us),
                                    ('signal_separation', units.us),
                                    ('event_separation', units.us)):
                argval = getattr(args, argname)
                if argval is not None:
                    if factor is not None:
                        argval = int(factor * argval)
                    trigger_settings_override[argname] = argval

            trigger_settings_override['trigger_data_filename'] = os.path.join(data_info_entry['location'],
                                                                              'trigger_data.hdf5')

            log.info("Building events for %s", run_doc['name'])
            config_dict = {'DEFAULT': {'run_doc_id': run_doc['_id']},
                           'pax': {'output_name': data_info_entry['location'],
                                   'n_cpus': args.cpus},
                           'BSON': {'fields_to_ignore': [],
                                    'overwrite_output': True},
                           'MongoDB': mongo_settings_override,
                           'Trigger': trigger_settings_override}

            if args.force_multiplicity_trigger is not None:
                level = args.force_multiplicity_trigger
                config_dict.setdefault('Trigger.DecideTriggers', {})
                config_dict['Trigger.DecideTriggers']['trigger_probability'] = {
                    '0': {str(level): 1},
                    '1': {str(level): 1},
                    '2': {str(level): 1}}

            try:
                p = core.Processor(config_names=['XENON1T' if args.detector == 'tpc' else 'XENON1T_MV'] + args.config,
                                   config_paths=args.config_path,
                                   config_dict=config_dict)
                p.run()

            # If a timeout occurred, set the status of this run to 'error'
            # Add other exceptions as they come during commissioning
            except pymongo.errors.ServerSelectionTimeoutError as e:
                log.exception(e)
                runs.update({'name': run_doc['name'], 'detector' : args.detector},
                            {'$set': {status_name: 'error'}})

            if not args.secret_mode:
                data_info_entry['status'] = 'verifying'
                runs.update({'_id': run_doc['_id'],
                             'data.host' : data_info_entry['host']},
                            {'$set': {'data.$' : data_info_entry}})

            # Copy the log file to the output dir, then clear it for the next run
            shutil.copyfile('eventbuilder.log', data_info_entry['location'] + '/eventbuilder.log')
            open('eventbuilder.log', mode='w').close()

        # If we're trying to build a single run, don't try again to find it
        if args.run_name or args.run:
            break


def setup_logging(loglevel='DEBUG'):
    # Set up logging to file
    logging.basicConfig(level=loglevel,
                        format='%(asctime)s %(name)s %(levelname)-8s %(message)s',
                        datefmt='%m-%d %H:%M',
                        filename='eventbuilder.log',
                        filemode='w')
    # define a Handler which writes INFO messages or higher to the sys.stderr
    console = logging.StreamHandler()
    console.setLevel(logging.DEBUG)
    # set a format which is simpler for console use
    formatter = logging.Formatter('%(asctime)s %(name)-12s: '
                                  '%(levelname)-8s %(message)s')
    # tell the handler to use this format
    console.setFormatter(formatter)
    # add the handler to the root logger
    logging.getLogger('').addHandler(console)
    return logging.getLogger('Eventbuilder')


def get_command_line_arguments():
    """Return the parserd arguments from the command line (from ArgumentParser.parse_args())
    """
    parser = argparse.ArgumentParser(description="Build XENON1T events from the DAQ MongoDB.")

    parser.add_argument('--config',
                        default=['event_builder'],
                        nargs='+',
                        help="Name(s) of the pax configuration(s) to use. "
                             "Should be a space-separated list; default is only event_builder")
    parser.add_argument('--config_path',
                        default=[],
                        nargs='+',
                        help="Path(s) of the configuration file(s) to use.")

    parser.add_argument('--cpus', default=1, nargs='?',
                        help="Number of CPUs to use. Default is 1; can be 'all'.")
    parser.add_argument('--detector', default='tpc', type=str,
                        help="Detector to build events for")
    parser.add_argument('--log', default='INFO',
                        help="Logging level to use, e.g. DEBUG")
    parser.add_argument('--search_window', type=float,
                        help='Length of time range (in sec, float) to get pulse data for in each iteration.')
    parser.add_argument('--secret_mode', action='store_true',
                        help="Never write anything to the runs db. Use only for testing!")

    connection_group = parser.add_argument_group(title='MongoDB connection settings')
    connection_group.add_argument('--host', default='gw', type=str,
                                  help='MongoDB hostname')
    connection_group.add_argument('--port', default=27017, type=int,
                                  help='Port on host where MongoDB runs')
    connection_group.add_argument('--user', default='eb', type=str,
                                  help='User to connect to MongoDB')
    connection_group.add_argument('--password', type=str, default=os.environ.get('MONGO_PASSWORD'),
                                  help='Password to connect to MongoDB. '
                                       'If not provided, will try to use MONGO_PASSWORD from env')

    single_run_group = parser.add_mutually_exclusive_group()
    single_run_group.add_argument('--run_name', type=str,
                                  help="Instead of building all waiting_to_be_processed runs, "
                                       "look for this specific run name and build it.")
    single_run_group.add_argument('--run', type=int,
                                  help="Instead of building all waiting_to_be_processed runs, "
                                       "look for this specific run number and build it.")

    trigger_group = parser.add_argument_group(title='Trigger settings',
                                              description='Override default settings for the trigger.')
    trigger_group.add_argument('--force_multiplicity_trigger', type=int,
                               help='Forces the trigger into a more basic mode: always trigger on a signal of more than'
                                    'force_multiplicity_trigger pulses, and never on smaller signals.')
    trigger_group.add_argument('--signal_separation', type=float,
                               help='If no pulses start for this length of time (us),'
                                    'a signal ends / a new signal can start.')
    trigger_group.add_argument('--event_separation', type=float,
                               help='If there are no triggers for this length of time (us),'
                                    'a new event can start.')
    trigger_group.add_argument('--ignore_rundb_trigger_settings', action='store_true',
                               help='Instead of loading trigger settings from the run db, use the default settings from'
                                    'the pax configuration. Command-line options override both in any case.')

    trigger_group.add_argument('--left_extension', type=float,
                               help="Minimum range before each trigger to save (us). Is abs()ed before it is used.")
    trigger_group.add_argument('--right_extension', type=float,
                               help='Minimum time after trigger to save (us).')

    parser.add_argument('--impatient', action='store_true',
                        help="Shut down if there are no more runs to process. "
                             "Default behaviour is instead to wait for more data")
    parser.add_argument('--wait', default=1, type=int,
                        help="Wait time before searching for new runs again if none were found (sec)")

    args = parser.parse_args()
    return args

if __name__ == "__main__":
    main()

#!/usr/bin/env python
"""Event builder routines

The event builder is responsible for finding events within the DAQ output
stream and turning this into events that the end user can process.  The data is
fetched untriggered, which means that there is no event structure.  Or rather,
it is just a stream of PMT pulses that need to be assembled into events.  This
is exactly what this code does.  There are two inputs requires:

* Location of runs database
* Trigger settings

This code is meant to run in production, therefore a runs database must be
 provided.  This code will use this database to locate what data needs to be
 processed and handle it appropriately.

This code is also responsible triggering (i.e., deciding which events to
record).  At present there are two stages to the triggering: a pretrigger and
a pax-event trigger.  The pretrigger is a simple sliding window coincidence
trigger that runs over the data to identify possible signals.  The parameters
of this are then, clearly, the size of the window and the coincidence
requirement.  Another parameter is how much data to save around the discovered
peak, which often is an S2.

The second level trigger, which we often do not run, processed the event in pax
and is used to make, e.g., radial cuts.  At present, the code just writes HDF5
files.

It is worth mentioning that is an 'expert modes' with a flag for mega events:
an event of one second is made that can be used for computing the trigger
efficiency.
"""
import argparse
import logging
import os
import pymongo
import time
from pax import core, units
from pax.MongoManager import MongoManager


def main():
    """Start running the event builder
    Find a dataset to process, then process it with settings from command line.
    """
    args = get_command_line_arguments()
    log = setup_logging(loglevel=args.log)

    mongo_manager = MongoManager(config={k: eval('args.%s' % k, dict(args=args))
                                         for k in ('user', 'password', 'host', 'port')})
    runs = mongo_manager.get_database('run').get_collection('runs_new')

    # Build the query used to search for runs
    status_name = 'trigger.status'
    if args.name:
        run_query = {'name': args.name, 'detector' : args.detector}
    else:
        run_query = {status_name: 'waiting_to_be_processed',
                     'detector' : args.detector}
    log.info("Starting run search with query %s" % run_query)

    while 1:
        run_doc = runs.find_one_and_update(run_query,
                                           {'$set': {status_name: 'staging'}})

        if run_doc is None:
            if args.impatient:
                log.info("Too impatient to wait for data, exiting...")
                break
            else:
                log.info("No runs to process... waiting %d seconds", args.wait)
                time.sleep(args.wait)
        else:
            # Set the mongo settings
            #   First priority: command line args
            #   Second priority: rundb settings (from run_doc['trigger']
            #   Third priority: defaults from event_builder.ini (pax will take care of this)
            mongo_settings = run_doc['trigger']
            for argname, factor in (('window', units.us),
                                    ('left_extension', units.us),
                                    ('right_extension', units.us),
                                    ('search_window', units.s),
                                    ('multiplicity', None),
                                    ('mega_events', None),
                                    ('detector', None),
                                    ('user', None),
                                    ('password', None),
                                    ('host', None),
                                    ('port', None)):
                argval = getattr(args, argname)
                if argval is not None:
                    if factor is not None:
                        argval = int(factor * argval)
                    mongo_settings[argname] = argval

            log.info("Building events for %s", run_doc['name'])
            config_dict = {'DEFAULT': {'run_doc_id': run_doc['_id']},
                           'pax': {'output_name': run_doc['name'],
                                   'n_cpus': args.cpus},
                           'BSON': {'fields_to_ignore': [],
                                    'overwrite_output': True},
                           'MongoDB': mongo_settings,
                           }
            try:
                p = core.Processor(config_names=['XENON1T' if args.detector == 'tpc' else 'XENON1T_MV',
                                                 'eventbuilder'],
                                   config_dict=config_dict)
                p.run()

            # If a timeout occurred, set the status of this run to 'error'
            # Add other exceptions as they come during commissioning
            except pymongo.errors.ServerSelectionTimeoutError as e:
                log.exception(e)
                runs.update({'name': args.name, 'detector' : args.detector},
                            {'$set': {status_name: 'error'}})

            # Copy the log file to the output dir, then clear it for the next run
            import shutil
            shutil.copyfile('eventbuilder.log', run_doc['name'] + '/eventbuilder.log')
            open('eventbuilder.log', mode='w').close()

        # If we're trying to build a single run, don't try again to find it
        if args.name:
            break


def setup_logging(loglevel='DEBUG'):
    # Set up logging to file
    logging.basicConfig(level=loglevel,
                        format='%(asctime)s %(name)s %(levelname)-8s %(message)s',
                        datefmt='%m-%d %H:%M',
                        filename='eventbuilder.log',
                        filemode='w')
    # define a Handler which writes INFO messages or higher to the sys.stderr
    console = logging.StreamHandler()
    console.setLevel(logging.DEBUG)
    # set a format which is simpler for console use
    formatter = logging.Formatter('%(asctime)s %(name)-12s: '
                                  '%(levelname)-8s %(message)s')
    # tell the handler to use this format
    console.setFormatter(formatter)
    # add the handler to the root logger
    logging.getLogger('').addHandler(console)
    return logging.getLogger('Eventbuilder')


def get_command_line_arguments():
    """Command line argument processing

    This routine is also responsible for setting up logging.
    """
    parser = argparse.ArgumentParser(description="Build XENON1T events from the"
                                                 " data aquisiton. This tools "
                                                 "starts the distributed "
                                                 "processing of events.")

    connection_group = parser.add_argument_group(title='MongoDB connection settings')
    connection_group.add_argument('--host', default='gw', type=str,
                                  help='MongoDB hostname')
    connection_group.add_argument('--port', default=27017, type=int,
                                  help='Port on host where MongoDB runs')
    connection_group.add_argument('--user', default='eb', type=str,
                                  help='User to connect to MongoDB')
    connection_group.add_argument('--password', type=str, default=os.environ.get('MONGO_PASSWORD'),
                                  help='Password to connect to MongoDB. '
                                       'If not provided, will try to use MONGO_PASSWORD from env')

    parser.add_argument('--name',
                        type=str,
                        help="Instead of building all waiting_to_be_processed runs,"
                             "look for this specific run and build it.")
    parser.add_argument('--detector',
                        type=str,
                        default='tpc',
                        help="Detector to build events for")
    parser.add_argument('--impatient',
                        action='store_true',
                        help="Event builder will not wait for new data")
    parser.add_argument('--mega_events',
                        action='store_true',
                        help="OVERRIDES ALL OTHER OPTIONS: build mega-events with same length as search window.")
    parser.add_argument('--cpus', default=1,
                        help="Number of CPUs to use. Default is 1; can be 'all'.",
                        nargs='?')

    trigger_group = parser.add_argument_group(title='Event builder settings',
                                              description='Configure trigger')
    trigger_group.add_argument('--multiplicity',
                               type=int,
                               help='Number of coincident pulses required for a trigger',)
    trigger_group.add_argument('--window',
                               type=int,
                               help='Size of coincidence trigger sliding window (us)',)
    trigger_group.add_argument('--left_extension',
                               type=int,
                               help='Minimum time before trigger to save (us). Must be negative, so it is '
                                    'actually the time after trigger to save, if you think about it, but '
                                    "please don't, we just like to torture unsuspecting command line users, har har!")
    trigger_group.add_argument('--right_extension',
                               type=int,
                               help='Minimum time after trigger to save (us)')
    trigger_group.add_argument('--search_window',
                               type=float,
                               help='Size of initial pulse search window (in seconds!!!). Can be float.')

    parser.add_argument('--wait',
                        default=1,
                        type=int,
                        help="Wait time before searching for new runs again if none were found (sec)")

    parser.add_argument('--log', default='INFO',
                        help="Set log level, e.g. DEBUG")

    args = parser.parse_args()
    return args

if __name__ == "__main__":
    main()
